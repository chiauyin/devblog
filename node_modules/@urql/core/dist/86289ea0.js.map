{"version":3,"file":"86289ea0.js","sources":["../src/utils/error.ts","../src/utils/stringifyVariables.ts","../src/utils/result.ts","../src/internal/fetchOptions.ts","../src/internal/fetchSource.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: any,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: result.data,\n  error: Array.isArray(result.errors)\n    ? new CombinedError({\n        graphQLErrors: result.errors,\n        response,\n      })\n    : undefined,\n  extensions:\n    (typeof result.extensions === 'object' && result.extensions) || undefined,\n});\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import { Kind, print, DocumentNode } from 'graphql';\n\nimport { stringifyVariables } from '../utils';\nimport { Operation } from '../types';\n\nexport interface FetchBody {\n  query: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\nconst getOperationName = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION && node.name) {\n      return node.name.value;\n    }\n  }\n};\n\nconst shouldUseGet = (operation: Operation): boolean => {\n  return (\n    operation.operationName === 'query' && !!operation.context.preferGetMethod\n  );\n};\n\nexport const makeFetchBody = (request: {\n  query: DocumentNode;\n  variables?: object;\n}): FetchBody => ({\n  query: print(request.query),\n  operationName: getOperationName(request.query),\n  variables: request.variables || undefined,\n  extensions: undefined,\n});\n\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod = shouldUseGet(operation);\n  let url = operation.context.url;\n  if (!useGETMethod || !body) return url;\n\n  url += `?query=${encodeURIComponent(body.query)}`;\n\n  if (body.variables) {\n    url += `&variables=${encodeURIComponent(\n      stringifyVariables(body.variables)\n    )}`;\n  }\n\n  if (body.extensions) {\n    url += `&extensions=${encodeURIComponent(\n      stringifyVariables(body.extensions)\n    )}`;\n  }\n\n  return url;\n};\n\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const useGETMethod = shouldUseGet(operation);\n\n  const extraOptions =\n    typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions || {};\n\n  return {\n    ...extraOptions,\n    body: !useGETMethod && body ? JSON.stringify(body) : undefined,\n    method: useGETMethod ? 'GET' : 'POST',\n    headers: {\n      'content-type': 'application/json',\n      ...extraOptions.headers,\n    },\n  };\n};\n","import { Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\nimport { make } from 'wonka';\n\nconst executeFetch = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Promise<OperationResult> => {\n  const fetcher = operation.context.fetch;\n\n  let statusNotOk = false;\n  let response: Response;\n\n  return (fetcher || fetch)(url, fetchOptions)\n    .then((res: Response) => {\n      response = res;\n      statusNotOk =\n        res.status < 200 ||\n        res.status >= (fetchOptions.redirect === 'manual' ? 400 : 300);\n      return res.json();\n    })\n    .then((result: any) => {\n      if (!('data' in result) && !('errors' in result)) {\n        throw new Error('No Content');\n      }\n\n      return makeResult(operation, result, response);\n    })\n    .catch((error: Error) => {\n      if (error.name !== 'AbortError') {\n        return makeErrorResult(\n          operation,\n          statusNotOk ? new Error(response.statusText) : error,\n          response\n        );\n      }\n    }) as Promise<OperationResult>;\n};\n\nexport const makeFetchSource = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n) => {\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined' ? new AbortController() : null;\n\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) {\n          return;\n        } else if (abortController) {\n          fetchOptions.signal = abortController.signal;\n        }\n\n        return executeFetch(operation, url, fetchOptions);\n      })\n      .then((result: OperationResult | undefined) => {\n        if (!ended) {\n          ended = true;\n          if (result) next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n"],"names":["const","rehydrateGraphQlError","error","GraphQLError","this","CombinedError","message","networkErr","graphQlErrs","undefined","err","generateErrorMessage","networkError","normalizedGraphQLErrors","response","Error","seen","Set","cache","WeakMap","stringify","x","JSON","Array","out","i","l","value","Object","key","Math","keys","stringifyVariables","makeResult","operation","result","data","graphQLErrors","extensions","makeErrorResult","getOperationName","query","node","Kind","shouldUseGet","request","print","operationName","variables","body","useGETMethod","_extends","method","headers","extraOptions","url","fetchOptions","make","abortController","AbortController","ended","statusNotOk","fetch","res","executeFetch","next","complete","encodeURIComponent"],"mappings":"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"}