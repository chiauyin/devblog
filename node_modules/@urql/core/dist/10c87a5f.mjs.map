{"version":3,"file":"10c87a5f.mjs","sources":["../src/utils/error.ts","../src/utils/stringifyVariables.ts","../src/utils/result.ts","../src/internal/fetchOptions.ts","../src/internal/fetchSource.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: any,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: result.data,\n  error: Array.isArray(result.errors)\n    ? new CombinedError({\n        graphQLErrors: result.errors,\n        response,\n      })\n    : undefined,\n  extensions:\n    (typeof result.extensions === 'object' && result.extensions) || undefined,\n});\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import { Kind, print, DocumentNode } from 'graphql';\n\nimport { stringifyVariables } from '../utils';\nimport { Operation } from '../types';\n\nexport interface FetchBody {\n  query: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\nconst getOperationName = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION && node.name) {\n      return node.name.value;\n    }\n  }\n};\n\nconst shouldUseGet = (operation: Operation): boolean => {\n  return (\n    operation.operationName === 'query' && !!operation.context.preferGetMethod\n  );\n};\n\nexport const makeFetchBody = (request: {\n  query: DocumentNode;\n  variables?: object;\n}): FetchBody => ({\n  query: print(request.query),\n  operationName: getOperationName(request.query),\n  variables: request.variables || undefined,\n  extensions: undefined,\n});\n\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod = shouldUseGet(operation);\n  let url = operation.context.url;\n  if (!useGETMethod || !body) return url;\n\n  url += `?query=${encodeURIComponent(body.query)}`;\n\n  if (body.variables) {\n    url += `&variables=${encodeURIComponent(\n      stringifyVariables(body.variables)\n    )}`;\n  }\n\n  if (body.extensions) {\n    url += `&extensions=${encodeURIComponent(\n      stringifyVariables(body.extensions)\n    )}`;\n  }\n\n  return url;\n};\n\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const useGETMethod = shouldUseGet(operation);\n\n  const extraOptions =\n    typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions || {};\n\n  return {\n    ...extraOptions,\n    body: !useGETMethod && body ? JSON.stringify(body) : undefined,\n    method: useGETMethod ? 'GET' : 'POST',\n    headers: {\n      'content-type': 'application/json',\n      ...extraOptions.headers,\n    },\n  };\n};\n","import { Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\nimport { make } from 'wonka';\n\nconst executeFetch = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Promise<OperationResult> => {\n  const fetcher = operation.context.fetch;\n\n  let statusNotOk = false;\n  let response: Response;\n\n  return (fetcher || fetch)(url, fetchOptions)\n    .then((res: Response) => {\n      response = res;\n      statusNotOk =\n        res.status < 200 ||\n        res.status >= (fetchOptions.redirect === 'manual' ? 400 : 300);\n      return res.json();\n    })\n    .then((result: any) => {\n      if (!('data' in result) && !('errors' in result)) {\n        throw new Error('No Content');\n      }\n\n      return makeResult(operation, result, response);\n    })\n    .catch((error: Error) => {\n      if (error.name !== 'AbortError') {\n        return makeErrorResult(\n          operation,\n          statusNotOk ? new Error(response.statusText) : error,\n          response\n        );\n      }\n    }) as Promise<OperationResult>;\n};\n\nexport const makeFetchSource = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n) => {\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined' ? new AbortController() : null;\n\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) {\n          return;\n        } else if (abortController) {\n          fetchOptions.signal = abortController.signal;\n        }\n\n        return executeFetch(operation, url, fetchOptions);\n      })\n      .then((result: OperationResult | undefined) => {\n        if (!ended) {\n          ended = true;\n          if (result) next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n"],"names":["error","GraphQLError","this","CombinedError","message","networkErr","graphQlErrs","undefined","err","generateErrorMessage","networkError","rehydrateGraphQlError","normalizedGraphQLErrors","response","Error","seen","Set","cache","WeakMap","x","JSON","stringify","Array","out","i","l","value","Object","key","Math","keys","operation","result","data","graphQLErrors","extensions","print","request","query","node","Kind","operationName","getOperationName","variables","url","body","encodeURIComponent","stringifyVariables","useGETMethod","_extends","method","headers","extraOptions","make","abortController","AbortController","ended","fetchOptions","statusNotOk","fetch","res","makeResult","makeErrorResult","executeFetch","next","complete"],"mappings":"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"}