{"version":3,"file":"40364ab3.min.js","sources":["../src/utils/error.ts","../src/utils/stringifyVariables.ts","../src/utils/result.ts","../src/internal/fetchOptions.ts","../src/internal/fetchSource.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: any,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: result.data,\n  error: Array.isArray(result.errors)\n    ? new CombinedError({\n        graphQLErrors: result.errors,\n        response,\n      })\n    : undefined,\n  extensions:\n    (typeof result.extensions === 'object' && result.extensions) || undefined,\n});\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import { Kind, print, DocumentNode } from 'graphql';\n\nimport { stringifyVariables } from '../utils';\nimport { Operation } from '../types';\n\nexport interface FetchBody {\n  query: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\nconst getOperationName = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION && node.name) {\n      return node.name.value;\n    }\n  }\n};\n\nconst shouldUseGet = (operation: Operation): boolean => {\n  return (\n    operation.operationName === 'query' && !!operation.context.preferGetMethod\n  );\n};\n\nexport const makeFetchBody = (request: {\n  query: DocumentNode;\n  variables?: object;\n}): FetchBody => ({\n  query: print(request.query),\n  operationName: getOperationName(request.query),\n  variables: request.variables || undefined,\n  extensions: undefined,\n});\n\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod = shouldUseGet(operation);\n  let url = operation.context.url;\n  if (!useGETMethod || !body) return url;\n\n  url += `?query=${encodeURIComponent(body.query)}`;\n\n  if (body.variables) {\n    url += `&variables=${encodeURIComponent(\n      stringifyVariables(body.variables)\n    )}`;\n  }\n\n  if (body.extensions) {\n    url += `&extensions=${encodeURIComponent(\n      stringifyVariables(body.extensions)\n    )}`;\n  }\n\n  return url;\n};\n\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const useGETMethod = shouldUseGet(operation);\n\n  const extraOptions =\n    typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions || {};\n\n  return {\n    ...extraOptions,\n    body: !useGETMethod && body ? JSON.stringify(body) : undefined,\n    method: useGETMethod ? 'GET' : 'POST',\n    headers: {\n      'content-type': 'application/json',\n      ...extraOptions.headers,\n    },\n  };\n};\n","import { Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\nimport { make } from 'wonka';\n\nconst executeFetch = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Promise<OperationResult> => {\n  const fetcher = operation.context.fetch;\n\n  let statusNotOk = false;\n  let response: Response;\n\n  return (fetcher || fetch)(url, fetchOptions)\n    .then((res: Response) => {\n      response = res;\n      statusNotOk =\n        res.status < 200 ||\n        res.status >= (fetchOptions.redirect === 'manual' ? 400 : 300);\n      return res.json();\n    })\n    .then((result: any) => {\n      if (!('data' in result) && !('errors' in result)) {\n        throw new Error('No Content');\n      }\n\n      return makeResult(operation, result, response);\n    })\n    .catch((error: Error) => {\n      if (error.name !== 'AbortError') {\n        return makeErrorResult(\n          operation,\n          statusNotOk ? new Error(response.statusText) : error,\n          response\n        );\n      }\n    }) as Promise<OperationResult>;\n};\n\nexport const makeFetchSource = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n) => {\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined' ? new AbortController() : null;\n\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) {\n          return;\n        } else if (abortController) {\n          fetchOptions.signal = abortController.signal;\n        }\n\n        return executeFetch(operation, url, fetchOptions);\n      })\n      .then((result: OperationResult | undefined) => {\n        if (!ended) {\n          ended = true;\n          if (result) next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n"],"names":["const","rehydrateGraphQlError","error","GraphQLError","this","CombinedError","message","networkErr","graphQlErrs","undefined","err","generateErrorMessage","networkError","normalizedGraphQLErrors","response","Error","seen","Set","cache","WeakMap","stringify","x","JSON","Array","out","i","l","value","Object","key","Math","keys","stringifyVariables","makeResult","operation","result","data","graphQLErrors","extensions","makeErrorResult","getOperationName","query","node","Kind","shouldUseGet","request","print","operationName","variables","body","useGETMethod","_extends","method","headers","extraOptions","url","fetchOptions","make","abortController","AbortController","ended","statusNotOk","fetch","res","executeFetch","next","complete","encodeURIComponent"],"mappings":"mWAEAA,IAkBMC,WAAyBC,SACR,mBACZ,IAAIC,eAAaD,GACE,oBAAYA,UAC/B,IAAIC,eACTD,UACAA,QACAA,SACAA,YACAA,OACAA,EACAA,cAAoB,IAGfA,uBAoCAE,iBA/BEC,8DAmBHC,WAvDRC,EACAC,OAEIN,EAAQ,eACOO,IAAfF,EACML,EAAQ,aAAaK,oBAG3BC,GACFA,oBAAoBE,MACT,aAAaA,kBAInBR,UAyCWS,CAAqBC,sBAHa,QAChDX,gBAIIK,aAEM,6BACGA,qBACMO,oBACDD,gBACJE,gHA3BeC,OCvC7BC,EAAO,IAAIC,IACXC,EAAQ,IAAIC,QAEZC,WAAaC,MACP,OAANA,GAAcL,MAASK,SAClB,UACe,0BACfC,eAAeD,IAAM,MACnBA,gBACFD,EAAUC,eACRE,cAAcF,YACnBG,EAAM,IACDC,EAAI,EAAGC,EAAIL,SAAUI,EAAIC,EAAGD,OAC/BA,IAAOD,GAAO,SACZG,EAAQP,EAAUC,EAAEI,OACJ,EAAfE,SAAmBA,EAAQ,cAGpCH,EAAO,WAIII,YAAYP,mBACLA,eAAiBA,gBAAkBO,cAC/CC,EAAMX,MAAUG,IAAMS,uBAAuB,UAAU,GAC7DZ,MAAUG,EAAGQ,gBACOA,iBAGbR,KACC,MACG,EAAGK,EAAIK,SAAaN,EAAIC,EAAGD,SAChCI,EAAME,EAAKN,GACXE,EAAQP,EAAUC,EAAEQ,QAEP,EAAbL,WAAgBA,GAAO,KAC3BA,GAAOJ,EAAUS,GAAO,IAAMF,mBAItBN,GACZG,EAAO,KAIIQ,WAAsBX,oBAE1BD,EAAUC,IC5CNY,WACXC,EACAC,EACArB,SACqB,WACrBoB,EACAE,KAAMD,OACNjC,MAAOqB,cAAcY,UACjB,IAAI9B,EAAc,CAChBgC,cAAeF,kBACfrB,SAEFL,EACJ6B,WACgC,+BAAYH,mBAAsB1B,IAGvD8B,WACXL,EACAhC,EACAY,SACqB,WACrBoB,EACAE,UAAM3B,EACNP,MAAO,IAAIG,EAAc,CACvBO,aAAcV,WACdY,IAEFwB,gBAAY7B,ICnBR+B,WAAoBC,WACfhB,EAAI,EAAGC,EAAIe,qBAA0BhB,EAAIC,EAAGD,SAC7CiB,EAAOD,cAAkBhB,MAC3BiB,SAAcC,6BAA6BD,cACtCA,eAKPE,WAAgBV,SAEU,UAA5BA,mBAAyCA,+HAIfW,SAGZ,CAChBJ,MAAOK,QAAMD,SACbE,cAAeP,EAAiBK,SAChCG,UAAWH,kBAAqBpC,EAChC6B,gBAAY7B,sCA6BZyB,EACAe,OAEMC,EAAeN,EAAaV,UAO3BiB,OAJqC,0CACtCjB,yBACAA,wBAAkC,IAItCe,MAAOC,GAAgBD,EAAO3B,eAAe2B,QAAQxC,EACrD2C,OAAQF,EAAe,MAAQ,OAC/BG,QAASF,qBACS,oBACbG,+CCtCPpB,EACAqB,EACAC,UAEOC,8CACCC,EACuB,oCAAc,IAAIC,gBAAoB,KAE/DC,GAAQ,gDAIJA,SAEOF,IACTF,SAAsBE,mBAnD9BxB,EACAqB,EACAC,OAKI1C,EADA+C,GAAc,SAFF3B,iBAKG4B,OAAOP,EAAKC,kBACtBO,YACMA,IAEI,IAAbA,UACAA,WAAyC,WAA1BP,WAAqC,IAAM,KACrDO,2BAEF5B,QACC,SAAUA,MAAa,WAAYA,SAC7BpB,MAAM,qBAGXkB,EAAWC,EAAWC,EAAQrB,sBAE/BZ,MACa,eAAfA,cACKqC,EACLL,EACA2B,EAAkB9C,MAAMD,cAAuBZ,EAC/CY,MAyBKkD,CAAa9B,EAAWqB,EAAKC,qBAE/BrB,OAEHyB,GAAQ,EACJzB,GAAQ8B,EAAK9B,GACjB+B,sBAKI,KAENR,6CDlCNxB,EACAe,OAEMC,EAAeN,EAAaV,YACxBA,cACLgB,GAAiBD,MAEf,UAAUkB,mBAAmBlB,uBAGlCM,GAAO,cAAcY,mBACnBnC,EAAmBiB,8BAKrBM,GAAO,eAAeY,mBACpBnC,EAAmBiB,gBAIhBM,GAhB4BA"}