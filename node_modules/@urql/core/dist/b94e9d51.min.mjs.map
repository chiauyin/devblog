{"version":3,"file":"b94e9d51.min.mjs","sources":["../src/utils/error.ts","../src/utils/stringifyVariables.ts","../src/utils/result.ts","../src/internal/fetchOptions.ts","../src/internal/fetchSource.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: any,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: result.data,\n  error: Array.isArray(result.errors)\n    ? new CombinedError({\n        graphQLErrors: result.errors,\n        response,\n      })\n    : undefined,\n  extensions:\n    (typeof result.extensions === 'object' && result.extensions) || undefined,\n});\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import { Kind, print, DocumentNode } from 'graphql';\n\nimport { stringifyVariables } from '../utils';\nimport { Operation } from '../types';\n\nexport interface FetchBody {\n  query: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\nconst getOperationName = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION && node.name) {\n      return node.name.value;\n    }\n  }\n};\n\nconst shouldUseGet = (operation: Operation): boolean => {\n  return (\n    operation.operationName === 'query' && !!operation.context.preferGetMethod\n  );\n};\n\nexport const makeFetchBody = (request: {\n  query: DocumentNode;\n  variables?: object;\n}): FetchBody => ({\n  query: print(request.query),\n  operationName: getOperationName(request.query),\n  variables: request.variables || undefined,\n  extensions: undefined,\n});\n\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod = shouldUseGet(operation);\n  let url = operation.context.url;\n  if (!useGETMethod || !body) return url;\n\n  url += `?query=${encodeURIComponent(body.query)}`;\n\n  if (body.variables) {\n    url += `&variables=${encodeURIComponent(\n      stringifyVariables(body.variables)\n    )}`;\n  }\n\n  if (body.extensions) {\n    url += `&extensions=${encodeURIComponent(\n      stringifyVariables(body.extensions)\n    )}`;\n  }\n\n  return url;\n};\n\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const useGETMethod = shouldUseGet(operation);\n\n  const extraOptions =\n    typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions || {};\n\n  return {\n    ...extraOptions,\n    body: !useGETMethod && body ? JSON.stringify(body) : undefined,\n    method: useGETMethod ? 'GET' : 'POST',\n    headers: {\n      'content-type': 'application/json',\n      ...extraOptions.headers,\n    },\n  };\n};\n","import { Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\nimport { make } from 'wonka';\n\nconst executeFetch = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Promise<OperationResult> => {\n  const fetcher = operation.context.fetch;\n\n  let statusNotOk = false;\n  let response: Response;\n\n  return (fetcher || fetch)(url, fetchOptions)\n    .then((res: Response) => {\n      response = res;\n      statusNotOk =\n        res.status < 200 ||\n        res.status >= (fetchOptions.redirect === 'manual' ? 400 : 300);\n      return res.json();\n    })\n    .then((result: any) => {\n      if (!('data' in result) && !('errors' in result)) {\n        throw new Error('No Content');\n      }\n\n      return makeResult(operation, result, response);\n    })\n    .catch((error: Error) => {\n      if (error.name !== 'AbortError') {\n        return makeErrorResult(\n          operation,\n          statusNotOk ? new Error(response.statusText) : error,\n          response\n        );\n      }\n    }) as Promise<OperationResult>;\n};\n\nexport const makeFetchSource = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n) => {\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined' ? new AbortController() : null;\n\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) {\n          return;\n        } else if (abortController) {\n          fetchOptions.signal = abortController.signal;\n        }\n\n        return executeFetch(operation, url, fetchOptions);\n      })\n      .then((result: OperationResult | undefined) => {\n        if (!ended) {\n          ended = true;\n          if (result) next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n"],"names":["error","GraphQLError","this","CombinedError","message","networkErr","graphQlErrs","undefined","err","generateErrorMessage","networkError","rehydrateGraphQlError","normalizedGraphQLErrors","response","Error","seen","Set","cache","WeakMap","x","JSON","stringify","Array","out","i","l","value","Object","key","Math","keys","operation","result","data","graphQLErrors","extensions","print","request","query","node","Kind","operationName","getOperationName","variables","url","body","encodeURIComponent","stringifyVariables","useGETMethod","_extends","method","headers","extraOptions","make","abortController","AbortController","ended","fetchOptions","statusNotOk","fetch","res","makeResult","makeErrorResult","executeFetch","next","complete"],"mappings":"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"}